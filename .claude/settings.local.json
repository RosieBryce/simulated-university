{
  "permissions": {
    "allow": [
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git push)",
      "Bash(python -c:*)",
      "Bash(cd /c/Users/DELL/workspace/code/simulated-university && python << 'EOF'\nimport sys\nfrom pathlib import Path\nimport pandas as pd\nsys.path.insert\\(0, str\\(Path.cwd\\(\\)\\)\\)\nsys.path.insert\\(0, str\\(Path.cwd\\(\\) / 'supporting_systems'\\)\\)\n\nfrom core_systems.student_generation_pipeline import generate_students\nfrom core_systems.program_enrollment_system import ProgramEnrollmentSystem\nfrom core_systems.engagement_system import EngagementSystem\nfrom core_systems.assessment_system import AssessmentSystem\nfrom core_systems.progression_system import ProgressionSystem\n\n# Simulate Year 1 \\(1046-47\\)\nprint\\(\"=== YEAR 1 \\(1046-47\\) ===\\\\n\"\\)\n\nCOHORT_SIZE = 500\nyear_index = 0\nacademic_year = \"1046-47\"\nseed = 42\n\n# 1. Generate students\nprint\\(\"Step 1: Generate students\"\\)\nnew_students = generate_students\\(n=COHORT_SIZE, seed=seed\\)\nprint\\(f\"  Generated: {len\\(new_students\\)} students\"\\)\n\n# 2. Assign student_ids\nprint\\(\"\\\\nStep 2: Assign student_ids\"\\)\nnew_students_df = new_students.copy\\(\\)\noffset = year_index * COHORT_SIZE\nnew_students_df[\"student_id\"] = range\\(offset, offset + len\\(new_students_df\\)\\)\nprint\\(f\"  Assigned IDs: {offset} to {offset + len\\(new_students_df\\) - 1}\"\\)\n\n# 3. Enroll students\nprint\\(\"\\\\nStep 3: Enroll students\"\\)\nenrollment_sys = ProgramEnrollmentSystem\\(\\)\nstatus_change = \"1046-09-01\"\nenrolled_df = enrollment_sys.enroll_students_batch\\(\n    new_students_df,\n    academic_year=academic_year,\n    status_change_at=status_change,\n\\)\nprint\\(f\"  Enrolled: {len\\(enrolled_df\\)} students\"\\)\nprint\\(f\"  Student ID range: {enrolled_df['student_id'].min\\(\\)} to {enrolled_df['student_id'].max\\(\\)}\"\\)\n\n# 4. Generate engagement\nprint\\(\"\\\\nStep 4: Generate engagement data\"\\)\nengagement_sys = EngagementSystem\\(\\)\nenrolled_clean = enrolled_df.loc[:, ~enrolled_df.columns.duplicated\\(\\)]\nweekly_df, semester_df = engagement_sys.generate_engagement_data\\(\n    enrolled_clean, weeks_per_semester=12, academic_year=academic_year\n\\)\nweekly_df[\"academic_year\"] = academic_year\nprint\\(f\"  Weekly records: {len\\(weekly_df\\)}\"\\)\nprint\\(f\"  Unique students in weekly: {weekly_df['student_id'].nunique\\(\\)}\"\\)\n\n# 5. Generate assessment\nprint\\(\"\\\\nStep 5: Generate assessment data\"\\)\nassessment_sys = AssessmentSystem\\(seed=seed\\)\nassessment_df = assessment_sys.generate_assessment_data\\(\n    enrolled_clean,\n    academic_year=academic_year,\n    assessment_date=\"1047-05-15\",\n    weekly_engagement_path=\"\",  # No existing engagement yet\n\\)\nprint\\(f\"  Assessment records: {len\\(assessment_df\\)}\"\\)\nprint\\(f\"  Unique students in assessment: {assessment_df['student_id'].nunique\\(\\)}\"\\)\nprint\\(f\"  Student ID range: {assessment_df['student_id'].min\\(\\)} to {assessment_df['student_id'].max\\(\\)}\"\\)\n\n# Check for data loss\nassessment_students = set\\(assessment_df['student_id'].unique\\(\\)\\)\nenrolled_students = set\\(enrolled_df['student_id'].astype\\(str\\).unique\\(\\)\\)\nmissing = enrolled_students - assessment_students\nprint\\(f\"\\\\n  Students in enrolled but NOT in assessment: {len\\(missing\\)}\"\\)\nif len\\(missing\\) <= 10:\n    print\\(f\"    Missing: {sorted\\(list\\(missing\\)\\)[:10]}\"\\)\n\n# 6. Compute progression\nprint\\(\"\\\\nStep 6: Compute progression\"\\)\nprogression_sys = ProgressionSystem\\(seed=seed\\)\nprogression_df = progression_sys.compute_progression\\(\n    assessment_df,\n    enrolled_clean,\n    academic_year=academic_year,\n    status_change_at=\"1047-09-01\",\n\\)\nprint\\(f\"  Progression records: {len\\(progression_df\\)}\"\\)\nprint\\(f\"  Unique students in progression: {progression_df['student_id'].nunique\\(\\)}\"\\)\n\nEOF)",
      "Bash(cd /c/Users/DELL/workspace/code/simulated-university && python << 'EOF'\nimport sys\nfrom pathlib import Path\nimport pandas as pd\nsys.path.insert\\(0, str\\(Path.cwd\\(\\)\\)\\)\nsys.path.insert\\(0, str\\(Path.cwd\\(\\) / 'supporting_systems'\\)\\)\n\nfrom core_systems.student_generation_pipeline import generate_students\nfrom core_systems.program_enrollment_system import ProgramEnrollmentSystem\n\nCOHORT_SIZE = 500\nseed = 42\n\nnew_students = generate_students\\(n=COHORT_SIZE, seed=seed\\)\nyear_index = 0\nnew_students_df = new_students.copy\\(\\)\noffset = year_index * COHORT_SIZE\nnew_students_df[\"student_id\"] = range\\(offset, offset + len\\(new_students_df\\)\\)\n\nprint\\(\"Before enrollment:\"\\)\nprint\\(f\"  Rows: {len\\(new_students_df\\)}\"\\)\nprint\\(f\"  student_id dtype: {new_students_df['student_id'].dtype}\"\\)\nprint\\(f\"  student_id range: {new_students_df['student_id'].min\\(\\)} to {new_students_df['student_id'].max\\(\\)}\"\\)\nprint\\(f\"  First 10 student_ids: {new_students_df['student_id'].head\\(10\\).tolist\\(\\)}\"\\)\nprint\\(f\"  Last 10 student_ids: {new_students_df['student_id'].tail\\(10\\).tolist\\(\\)}\"\\)\n\nenrollment_sys = ProgramEnrollmentSystem\\(\\)\n\n# Manually step through enroll_students_batch\nenrollments = []\nfor idx, student in new_students_df.iterrows\\(\\):\n    sid_raw = student.get\\('student_id', idx\\)\n    sid = str\\(sid_raw.iloc[0]\\) if isinstance\\(sid_raw, pd.Series\\) else str\\(sid_raw\\)\n    \n    personality_cols = [col for col in new_students_df.columns if col.startswith\\('refined_'\\)]\n    motivation_cols = [col for col in new_students_df.columns if col.startswith\\('motivation_'\\)]\n    \n    personality = {col: student[col] for col in personality_cols}\n    motivation = {col: student[col] for col in motivation_cols}\n    \n    enrollment = enrollment_sys.enroll_student\\(\n        student_id=sid,\n        clan=student['clan'],\n        personality=personality,\n        motivation=motivation\n    \\)\n    \n    enrollments.append\\({\n        'student_id': enrollment.student_id,\n        'program_code': enrollment.program_code,\n    }\\)\n    \n    if idx < 3:\n        print\\(f\"\\\\nidx={idx}:\"\\)\n        print\\(f\"  sid_raw={sid_raw}, type={type\\(sid_raw\\)}\"\\)\n        print\\(f\"  sid={sid}\"\\)\n        print\\(f\"  enrollment.student_id={enrollment.student_id}, type={type\\(enrollment.student_id\\)}\"\\)\n\nenrollment_df = pd.DataFrame\\(enrollments\\)\nprint\\(f\"\\\\n\\\\nAfter creating enrollment_df:\"\\)\nprint\\(f\"  Rows: {len\\(enrollment_df\\)}\"\\)\nprint\\(f\"  student_id dtype: {enrollment_df['student_id'].dtype}\"\\)\nprint\\(f\"  student_id range: {enrollment_df['student_id'].min\\(\\)} to {enrollment_df['student_id'].max\\(\\)}\"\\)\nprint\\(f\"  First 10: {enrollment_df['student_id'].head\\(10\\).tolist\\(\\)}\"\\)\nprint\\(f\"  Last 10: {enrollment_df['student_id'].tail\\(10\\).tolist\\(\\)}\"\\)\n\nEOF)",
      "Bash(cd:*)",
      "Bash(cd \"C:\\\\Users\\\\DELL\\\\workspace\\\\code\\\\simulated-university\" && python metaanalysis/assessment_visualization.py 2>&1)",
      "Bash(cd \"C:\\\\Users\\\\DELL\\\\workspace\\\\code\\\\simulated-university\" && python - <<'EOF'\nimport pandas as pd\n\n# Check assessment events\nassess = pd.read_csv\\('data/stonegrove_assessment_events.csv'\\)\nprint\\(\"=== Assessment Events ===\"\\)\nprint\\(f\"Total rows: {len\\(assess\\)}\"\\)\nprint\\(f\"component_code values: {assess['component_code'].value_counts\\(\\).to_dict\\(\\)}\"\\)\nprint\\(f\"\\\\nDistinct assessment_dates: {sorted\\(assess['assessment_date'].unique\\(\\)\\)[:8]}\"\\)\nprint\\(f\"\\\\ncombined_mark null on MIDTERM: {assess[assess['component_code']=='MIDTERM']['combined_mark'].isna\\(\\).all\\(\\)}\"\\)\nprint\\(f\"combined_mark null on FINAL: {assess[assess['component_code']=='FINAL']['combined_mark'].isna\\(\\).sum\\(\\)} nulls\"\\)\n\n# Sample FINAL rows\nprint\\(\"\\\\nSample FINAL rows:\"\\)\nprint\\(assess[assess['component_code']=='FINAL'][['student_id','academic_year','module_code','assessment_mark','combined_mark','grade','assessment_date']].head\\(6\\).to_string\\(\\)\\)\n\n# Check weekly engagement for semester column\nweekly = pd.read_csv\\('data/stonegrove_weekly_engagement.csv'\\)\nprint\\(\"\\\\n=== Weekly Engagement ===\"\\)\nprint\\(f\"Columns: {list\\(weekly.columns\\)}\"\\)\nprint\\(f\"semester values: {weekly['semester'].value_counts\\(\\).to_dict\\(\\)}\"\\)\n\n# Progression outcomes\nprog = pd.read_csv\\('data/stonegrove_progression_outcomes.csv'\\)\nprint\\(\"\\\\n=== Progression Outcomes ===\"\\)\nprint\\(f\"Total rows: {len\\(prog\\)}\"\\)\nprint\\(f\"Status dist: {prog['status'].value_counts\\(\\).to_dict\\(\\)}\"\\)\nprint\\(f\"Withdrawal rate: {prog[prog['status']=='withdrawn']['status'].count\\(\\)/len\\(prog\\)*100:.1f}%\"\\)\nEOF)",
      "Bash(cd \"C:\\\\Users\\\\DELL\\\\workspace\\\\code\\\\simulated-university\" && python - <<'EOF'\nimport pandas as pd\nimport numpy as np\n\ngo = pd.read_csv\\('data/stonegrove_graduate_outcomes.csv'\\)\nindiv = pd.read_csv\\('data/stonegrove_individual_students.csv'\\).drop_duplicates\\('student_id'\\)\nindiv['student_id'] = indiv['student_id'].astype\\(str\\)\ngo['student_id'] = go['student_id'].astype\\(str\\)\ndf = go.merge\\(indiv[['student_id','species','clan','socio_economic_rank','disabilities']], on='student_id', how='left'\\)\n\nprint\\(f\"Total graduates with outcomes: {len\\(go\\)}\"\\)\nprint\\(f\"\\\\n--- Degree classification ---\"\\)\nprint\\(go['degree_classification'].value_counts\\(\\)\\)\n\nprint\\(f\"\\\\n--- Outcome type ---\"\\)\nprint\\(go['outcome_type'].value_counts\\(\\)\\)\nprint\\(go['outcome_type'].value_counts\\(normalize=True\\).round\\(3\\)\\)\n\nprint\\(f\"\\\\n--- Professional level \\(employed only\\) ---\"\\)\nemp = go[go['outcome_type']=='employed']\nprint\\(emp['professional_level'].value_counts\\(normalize=True\\).round\\(3\\)\\)\n\nprint\\(f\"\\\\n--- Salary band \\(employed only\\) ---\"\\)\nprint\\(emp['salary_band'].value_counts\\(\\).sort_index\\(\\)\\)\n\nprint\\(f\"\\\\n--- Employment sector \\(employed only\\) ---\"\\)\nprint\\(emp['employment_sector'].value_counts\\(\\)\\)\n\nprint\\(f\"\\\\n--- Outcome by degree classification ---\"\\)\nprint\\(go.groupby\\('degree_classification'\\)['outcome_type'].value_counts\\(normalize=True\\).unstack\\(fill_value=0\\).round\\(3\\)\\)\n\nprint\\(f\"\\\\n--- Professional employment rate by degree classification ---\"\\)\nprint\\(go[go['outcome_type']=='employed'].groupby\\('degree_classification'\\)['professional_level']\n      .value_counts\\(normalize=True\\).unstack\\(fill_value=0\\).round\\(3\\)\\)\n\nprint\\(f\"\\\\n--- Outcome by species ---\"\\)\nprint\\(df.groupby\\('species'\\)['outcome_type'].value_counts\\(normalize=True\\).unstack\\(fill_value=0\\).round\\(3\\)\\)\n\nprint\\(f\"\\\\n--- Professional employment rate by SES \\(employed only\\) ---\"\\)\nemp2 = df[df['outcome_type']=='employed']\nprint\\(emp2.groupby\\('socio_economic_rank'\\)['professional_level']\n      .value_counts\\(normalize=True\\).unstack\\(fill_value=0\\).round\\(3\\)\\)\n\nprint\\(f\"\\\\n--- Avg salary band by SES \\(employed only\\) ---\"\\)\nprint\\(emp2.groupby\\('socio_economic_rank'\\)['salary_band'].mean\\(\\).round\\(2\\)\\)\nEOF)"
    ]
  }
}
